# Что может пойти не так с Redux Toolkit в ХХ и что можно использовать вместо него

**TLDR:** Польза сомнительна, а вред очевиден

Мотивация: я услышал на ретро, что мы хотим добавить в проект Redux Toolkit (RTK), и представил мрачное будущее. Тут я попытался предвидеть сложности, ожидающие нас с RTK и предложить альтернативу.

## 1. Почему RTK - отличная технология 
(которая плохо подходит для нашего случая)

* **RTK - opinionated.** Это значит, что он предоставляет рекомендуемую структуру папок (которую мы не можем использовать). У нас будут старые редусеры в lux/models и новые слайсы рядом с компонентом (логика обработки связанных по смыслу экшонов в 2 разных местах)  

* **Async thunks** будут автоматически отправлять экшены (новые будут, старые не будут - беспорядок)  

* **Mutability and reducers.** В RTK мы будем писать код, который выглядит так, как будто он mutable, но на самом деле immutable. В наших редьюсерах нам придется сохранять immutable своими силами вручную. Старые редусеры в моделях + новые слайсы в фичах рядом с компонентом. Все работают с одним стором из разных мест по разным паттернам.  

* **Мы и сами с усами.** У нас уже есть своя реализация createReducer, там почти нет boilerplate. И autoGeneratedReducer, makeSetStoreField тоже есть.

## 2. Почему React Query для нас не так плох, как RTK

* **Isolated.** Мы не трогаем redux store. Новый код отделяется от старого. Понятно, что новое, а что можно рефакторить (при беглом взгляде на компонент).

* **No boilerplate code at all.** Идеально подходит для хранения server state. Без actions, без их обработчиков. Пишем только функцию, которая описывает логику загрузки данных. Все, что нужно, возвращается из хука. (данные, ошибка, isLoading)

* **Easy refactoring** Выпилить из редукса - занести в квери (-80/+25). Не нужно переписывать старый boilerplate на новый более удобный boilerplate

* **Coexist.** Квери могут спокойно жить в проекте рядом с редуксом и медленно разрастаться, не запутывая и не усложняя при этом логику редукса (что неизбежно при внедрении RTK)

* **Недостаточек** заключается в том, что хоть мы и получим красивый код и современный подход - это все равно зоопарк технологий. Лучшее, чем может быть богата кодовая база - консистентность (которой у нас не будет) 

## 3. Сравнение кода
* **old** - 61 line in 4 files  
* **new** - 32 lines in 2 files  
\* Если использовать makeSetStoreField(), то и без React Query значительно сократится boilerplate.  

## 4. Выводы
* У нас есть утилиты, позволяющие без RTK комфортно работать с редуксом. Нужно ли нам затаскивать что-то новое? Я думаю, что нет. Но если нужно, то следует тщательно продумать как именно RTK облегчит (или усложнит?) нам жизнь и посмотреть в сторону альтернативных решений.  

## 5*. Мечты о микрофронтах  
* **No duplicate logic in python!** Мы можем избавиться от дублирования логики запроса в python. Предварительно загружаем queries на ssr сервере (автоматически заполняем QueryCache на этапе ssr, используя код, написанный для клиента): https://tanstack.com/query/v4/docs/react/guides/ssr#custom-ssr-with-susspense  
Но есть нюанс: тут надо выбрать загрузку или в питоне или в js, если будут обе по очереди - будет долго. Поэтому внедрить можно в микрофронтах, но не в xhh.  
В xhh нужен костыль, который позволит нам из питона прокидывать данные в ssr и там заполнять ими QueryCache (так же как мы делаем put_state сможем делать put_state_rq).  
**То же самое можно делать и сейчас с тхунками, без React Query**  

---

** Интересно почитать на досуге:
* [Как устроен React Query под капотом](https://tkdodo.eu/blog/inside-react-query)
* [Как заполнить кэш React Query на сервере при SSR](https://tanstack.com/query/v4/docs/react/guides/ssr)
* [Умельцы смастерили либу для обхода дерева на сервере и ожидания всех нужных промисов](https://github.com/FormidableLabs/react-ssr-prepass)